# 6-面向对象

## 6.0 面向对象的三要素

* 封装(类)、继承、多态

## 6.1 类与实例

* 定义类

```py
class Car:
    # 类的方法在定义时，需要传入参数，否则会报错
    def getCarInfo(self):
        print('车的信息')

    def moveCar(self):
        print('车在移动')
```

* 创建对象(类的实例)，对象可以赋予实例属性和方法

```py
class Car:
    def getCarInfo(self):
        print('车的信息')

    def moveCar(self):
        print('车在移动')

BMW = Car()
BMW.getCarInfo()
BMW.moveCar()

BMW.color='black'
print(BMW.color) # black

QQ = Car()
# print(QQ.color) # 报错，实例的属性不会影响类
```

* 类的公有属性，__init__方法实际上会自动调用，为类创建公有属性

```py
class Car:
    def __init__(self, *args, **kwargs):
        self.color='blue'
            
    def getCarInfo(self):
        print('车的信息')

    def moveCar(self):
        print('车在移动')

BMW = Car()
BMW.getCarInfo()
BMW.moveCar()

BMW.color='black'
print(BMW.color) # black

QQ = Car()
print(QQ.color) # blue
```

* self，类中的self关键字指向的是类实例的本身，类似于JS中的this

```py
class Car:
    def __init__(self, *args, **kwargs):
        self.color='blue' # 此时self指向的是实例的引用地址 <__main__.Car object at 0x00000168C5D0FF98>
        self.name='' # 由于类的方法用到name属性，此时声明可以避免报错
        if len(args)>0:
            self.name=args[0] # 使用参数列表，可以在创建实例时直接传入属性值

    def getCarInfo(self):
        print('%s车的信息'%self.name)

    def moveCar(self):
        print('%s车在移动'%self.name)

    def introduce(self):
        self.getCarInfo()
        self.moveCar()

BMW = Car('BMW')
# BMW.name='BMW'
BMW.introduce()

BMW2 = Car()
BMW2.introduce()
```

* 类的输出结果，__str__在print(实例)时会自动调用，必须要有返回值

```py
class Car:
    def __init__(self, *args, **kwargs):
        self.color='blue' # 此时self指向的是实例的引用地址 <__main__.Car object at 0x00000168C5D0FF98>
        self.name='' # 由于类的方法用到name属性，此时声明可以避免报错
        if len(args)>0:
            self.name=args[0] # 使用参数列表，可以在创建实例时直接传入属性值

        self.introduce()

    def __str__(self):
        return 'self' # __str__必须要有返回值

    def getCarInfo(self):
        print('%s车的信息'%self.name)

    def moveCar(self):
        print('%s车在移动'%self.name)

    def introduce(self):
        self.getCarInfo()
        self.moveCar()

BMW = Car('BMW')
BMW2 = Car()
print(BMW) # self
```

* 注意：禁止在类中对传入的可变类型参数，修改会更改全局变量的值，与函数中相同

```py
class Car:
    def __init__(self, args, **kwargs):
        self.color = (
            "blue"
        )  # 此时self指向的是实例的引用地址 <__main__.Car object at 0x00000168C5D0FF98>
        self.name = ""  # 由于类的方法用到name属性，此时声明可以避免报错
        if len(args) > 0:
            self.name = args[0]  # 使用参数列表，可以在创建实例时直接传入属性值
            # args[0] = "BMW"  # 如果将args转回list类型，则全局变量会被修改
            customName=args
            customName[0] = "BMW" # 由于py中变量的赋值是改变引用地址的指向，所以即使重新声明了实例变量，依然会污染全局变量

        self.introduce()

    def __str__(self):
        return "self"  # __str__必须要有返回值

    def getCarInfo(self):
        print("%s车的信息" % self.name)

    def moveCar(self):
        print("%s车在移动" % self.name)

    def introduce(self):
        self.getCarInfo()
        self.moveCar()


nameB = ["MSN", "MMM"]
BMW = Car(nameB)
BMW2 = Car(nameB)
print(nameB) # ['BMW', 'MMM']
# 可以发现全局变量nameB已经被修改了，因此在传入可变类型的全局变量时，在类中禁止对参数进行重新赋值
```

* 私有属性和私有方法
1. Python中没有像C++中public和private这些关键字来区别公有属性和私有属性，它是以属性命名方式来区分，如果在属性名前面加了2个下划线'__'，则表明该属性是私有属性，否则为公有属性（方法也是一样，方法名前面加了2个下划线的话表示该方法是私有的，否则为公有的）。
2. 私有方法不允许被对象直接调用，一般是在用对象内部的方法进行调用
3. 私有属性仅能通过对象的方法获得，保护数据

```py
class Cars:
    def __init__(self,producer):
        self.__producer=producer

    def set_name(self,attr):
        self.attr=attr
        self.__success('set_name')

    def __success(self,msg):
        print('%s成功'%msg)

    def get_producer(self):
        print(self.__producer)

bmw=Cars('生产者：哈哈哈')
bmw.set_name('bmw') # set_name成功
# bmw.__success('调用') # 会报错，私有方法仅在对象内部可以调用
bmw.get_producer() # 生产者：哈哈哈
# print(bmw.__producer) # 报错，私有属性不可被外部直接调用
```

* 对象的__del__方法会在被删除时调用

```py
class Cars:
    def __del__(self):
        print('del方法被调用')

newCar=Cars()
oldCar=newCar
# 对象的引用地址的链接数,比实际数量大1
import sys
print(sys.getrefcount(newCar)) # 3

del newCar
print(sys.getrefcount(oldCar)) # 2
print('准备删除对象newCar')
print('='*20)
# 准备删除对象newCar
# del方法被调用
# =============

# 这里由于有2个对象指向同一个引用地址，引用地址的链接为2
# 删除对象的引用地址的链接大于1时，del方法会被异步执行，而不是立即调用
```

## 6.2 继承

* 单继承
1. 私有的属性，不能通过对象直接访问，但是可以通过方法访问(不允许跨级)
2. 私有的方法，不能通过对象直接访问
3. 私有的属性、方法，不会被子类继承，也不能被访问
4. 一般情况下，私有的属性、方法都是不对外公布的，往往用来做内部的事情，起到安全的作用

```py
# 父类
class Animal:
    def eat(self):
        print('吃')

    def drint(self):
        print('喝')

    def sleep(self):
        print('睡')

# cat=Animal()
# cat.eat() # 吃

# 子类
class Dog(Animal):
    def bark(self):
        print('汪汪')

# dog1=Dog()
# dog1.eat() # 吃
# dog1.bark() # 汪汪

class FlyDog(Dog):
    def fly(self):
        print('飞天狗')

    # 重写bark方法
    def bark(self):
        print('飞天狗汪汪叫')

        # 调用被重写的方法
        # 方法1 调用方法的所属类名.方法(self)，参数self必传
        Dog.bark(self) # 汪汪
        # 方法2 super()表示上一级的类
        super().bark() # 汪汪

flydog1=FlyDog()
flydog1.eat() # 吃
flydog1.bark() # 飞天狗汪汪叫
flydog1.fly() # 飞天狗
```

* 多继承

```py
# 定义一个父类
class A:
    def printA(self):
        print('----A----')

# 定义一个父类
class B:
    def printB(self):
        print('----B----')

    def test(self):
        print('test-A')

# 定义一个子类，继承自A、B
class C(A,B):
    def printC(self):
        print('----C----')

    def test(self):
        print('test-B')

obj_C = C()
obj_C.printA() # ----A----
obj_C.printB() # ----B----
obj_C.test() # test-B 按照对象搜索方法是的先后顺序
print(C.__mro__) #可以查看C类的对象搜索方法时的先后顺序
# (<class '__main__.C'>, <class '__main__.A'>, <class '__main__.B'>, <class 'object'>)
```

## 6.3 多态

* 所谓多态：定义时的类型和运行时的类型不一样，此时就成为多态。多态的概念是应用于Java和C#这一类强类型语言中，而Python崇尚“鸭子类型”。

* Python伪代码实现Java或C#的多态

```py
class F1(object):
    def show(self):
        print('F1.show')

class S1(F1):
    def show(self):
        print('S1.show')

class S2(F1):
    def show(self):
        print('S2.show')

# 由于在Java或C#中定义函数参数时，必须指定参数的类型
# 为了让Func函数既可以执行S1对象的show方法，又可以执行S2对象的show方法，所以，定义了一个S1和S2类的父类
# 而实际传入的参数是：S1对象和S2对象

def Func(F1 obj):
    # Func函数需要接收一个F1类型或者F1子类的类型
    print(obj.show())

s1_obj = S1()
Func(s1_obj) # 在Func函数中传入S1类的对象 s1_obj，执行 S1 的show方法，结果：S1.show

s2_obj = S2()
Func(s2_obj) # 在Func函数中传入Ss类的对象 ss_obj，执行 Ss 的show方法，结果：S2.show
```

* Python “鸭子类型”

```py
class F1(object):
    def show(self):
        print('F1.show')

class S1(F1):
    def show(self):
        print('S1.show')

class S2(F1):
    def show(self):
        print('S2.show')

def Func(obj):
    print obj.show()

s1_obj = S1()
Func(s1_obj)

s2_obj = S2()
Func(s2_obj)
```

## 6.4 类属性和实例属性

* 实例属性：对象属性，使用__init__方法声明的属性，定义时候以self作为前缀。

* 类属性：类对象所拥有的属性，它被所有类对象的实例对象所共有，在内存中只存在一个副本，这个和C++中类的静态成员变量有点类似。对于公有的类属性，在类外可以通过类对象和实例对象访问。对于公有的类属性，在类外可以通过类对象和实例对象访问。

* 如果需要在类外修改类属性，必须通过类对象去引用然后进行修改。如果通过实例对象去引用，会产生一个同名的实例属性，这种方式修改的是实例属性，不会影响到类属性，并且之后如果通过实例对象去引用该名称的属性，实例属性会强制屏蔽掉类属性，即引用的是实例属性，除非删除了该实例属性。

* 私有成员与共有成员的区别：类的属性在定义的时候，如果以两个短下滑线“__”开头则表示是私有属性，否则就是公有属性。

```py
# 类属性
class People(object):
    name = 'Tom'  #公有的类属性
    __age = 12     #私有的类属性

p = People()

print(p.name)           #正确
print(People.name)      #正确
print(p.__age)            #错误，不能在类外通过实例对象访问私有的类属性
print(People.__age)        #错误，不能在类外通过类对象访问私有的类属性
```

* 如果需要在类外修改类属性，必须通过类对象去引用然后进行修改。如果通过实例对象去引用，会产生一个同名的实例属性，这种方式修改的是实例属性，不会影响到类属性，并且之后如果通过实例对象去引用该名称的属性，实例属性会强制屏蔽掉类属性，即引用的是实例属性，除非删除了该实例属性。

```py
# 通过实例(对象)去修改类属性
class People(object):
    country = 'china' #类属性

print(People.country) # china
p = People()
print(p.country) # china
p.country = 'japan'
print(p.country) # japan 实例属性会屏蔽掉同名的类属性
print(People.country) # china 类的属性不会因为实例属性的改变而变化
del p.country    # 删除实例属性后，读取的就是类属性
print(p.country) # china
```

## 6.5 类方法、实例方法、静态方法

* 实例方法：包括共有方法和私有方法，在实例中def定义的函数，私有方法以__开始。

* 类方法：在声明时需要加上@classmethod关键字，使用类名.类方法的方式调用，需要传入cls，cls指向类对象

* 静态方法：可以通过类名和对象名调用，但不能直接访问属于对象的成员，只能访问属于类的成员。定义静态方法@staticmethod，调用类名.方法名。静态方法可以不传入参数。

```py
class Game():
    # 类属性
    num=0
    # 实例方法
    def __init__(self):
        self.name='haha'

    # 类方法
    @classmethod # 装饰器，对原有的功能添加新功能
    def add_num(cls):
        cls.num=100

    # 静态方法
    @staticmethod
    def print_menu(): # 静态方法可以不传入参数
        print('-----游戏开始-----')
        print('-----退出游戏-----')

game=Game()
# 类方法的调用
Game.add_num()
print(Game.num) # 100
```

## 6.6 设计模式

* 6.6.1 简单工厂模式：工厂函数、工厂类对具体的生成环节进行了封装，这样有利于代码的后需扩展，即把功能划分的更具体。 代码详情见 /demo/6

* 6.6.2 工厂方法模式：定义了一个创建对象的接口(可以理解为函数)，但由子类决定要实例化的类是哪一个，工厂方法模式让类的实例化推迟到子类，抽象的基类提供了一个创建对象的方法，也叫作工厂方法。子类真正实现这个方法创建出具体产品。 创建者类不需要直到实际创建的产品是哪一个，选择了使用了哪个子类，自然也就决定了实际创建的产品是什么。 代码详情见 /demo/6